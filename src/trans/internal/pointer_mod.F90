MODULE POINTER_MOD

USE PARKIND1, ONLY : JPRB, JPIM

IMPLICIT NONE

INTEGER (KIND=JPIM), PARAMETER, PRIVATE :: NUNDEF = -HUGE(1_JPIM)

INTEGER, PARAMETER :: &
    & NTYPE_VOR  = B'00000000000000000000000000000001', &
    & NTYPE_DIV  = B'00000000000000000000000000000010', &
    & NTYPE_U    = B'00000000000000000000000000000100', &
    & NTYPE_V    = B'00000000000000000000000000001000', &
    & NTYPE_S    = B'00000000000000000000000000010000', &
    & NTYPE_EW   = B'00000000000000000000000000100000', &
    & NTYPE_NS   = B'00000000000000000000000001000000', &
    & NTYPE_U_EW = IOR (NTYPE_U, NTYPE_EW), &
    & NTYPE_V_EW = IOR (NTYPE_V, NTYPE_EW), &
    & NTYPE_S_EW = IOR (NTYPE_S, NTYPE_EW), &
    & NTYPE_S_NS = IOR (NTYPE_S, NTYPE_NS)

TYPE PTRS
  REAL (KIND=JPRB), POINTER :: P (:) => NULL ()
  INTEGER (KIND=JPIM) :: ITYPE   = 0
  INTEGER (KIND=JPIM) :: IPTR    = NUNDEF
  INTEGER (KIND=JPIM) :: IPTR_NS = NUNDEF
  CHARACTER*16 :: CLNAME = ''
END TYPE

TYPE PTRG
  REAL (KIND=JPRB), POINTER :: P (:,:) => NULL ()
  INTEGER (KIND=JPIM) :: ITYPE   = 0
  INTEGER (KIND=JPIM) :: IVSET   = NUNDEF
  INTEGER (KIND=JPIM) :: IRANK_L = NUNDEF
  INTEGER (KIND=JPIM) :: IRANK_G = NUNDEF
  CHARACTER*16 :: CLNAME = ''
END TYPE

CONTAINS

FUNCTION GREP_G2S (YDGP, PGTF, KVSET, KTYPE) RESULT (YLSP)

TYPE (PTRS), ALLOCATABLE :: YLSP (:)

TYPE (PTRG) :: YDGP (:)
REAL (KIND=JPRB), TARGET, OPTIONAL :: PGTF (:,:)
INTEGER, OPTIONAL :: KTYPE, KVSET

INTEGER :: ICOUNT, J, JPASS

DO JPASS = 1, 2

  ICOUNT = 0
  
  DO J = 1, SIZE (YDGP)

    IF (PRESENT (KTYPE)) THEN
      IF (YDGP (J)%ITYPE /= KTYPE) CYCLE
    ENDIF

    IF (PRESENT (KVSET)) THEN
      IF (YDGP (J)%IVSET /= KVSET) CYCLE
    ENDIF

    ICOUNT = ICOUNT + 1

    IF (ALLOCATED (YLSP)) THEN
      IF (PRESENT (PGTF)) THEN
        YLSP (ICOUNT)%P => PGTF (YDGP (J)%IRANK_L, :)
      ENDIF
      YLSP (ICOUNT)%ITYPE = YDGP (J)%ITYPE
    ENDIF

  ENDDO

  IF (JPASS == 1) THEN
    ALLOCATE (YLSP (ICOUNT))
  ENDIF

ENDDO

END FUNCTION

FUNCTION GREP_S2S (YDSP, KTYPE) RESULT (YLSP)

TYPE (PTRS), ALLOCATABLE :: YLSP (:)

TYPE (PTRS) :: YDSP (:)
INTEGER, OPTIONAL :: KTYPE

INTEGER :: ICOUNT, J, JPASS

DO JPASS = 1, 2

  ICOUNT = 0
  
  DO J = 1, SIZE (YDSP)

    IF (PRESENT (KTYPE)) THEN
      IF (YDSP (J)%ITYPE /= KTYPE) CYCLE
    ENDIF

    ICOUNT = ICOUNT + 1

    IF (ALLOCATED (YLSP)) THEN
      YLSP (ICOUNT)%P => YDSP (J)%P
      YLSP (ICOUNT)%ITYPE = YDSP (J)%ITYPE
      YLSP (ICOUNT)%IPTR  = YDSP (J)%IPTR
    ENDIF

  ENDDO

  IF (JPASS == 1) THEN
    ALLOCATE (YLSP (ICOUNT))
  ENDIF

ENDDO

END FUNCTION

SUBROUTINE PRINTG (YDGP, KLUN)

TYPE (PTRG) :: YDGP (:)
INTEGER :: KLUN

INTEGER :: J

WRITE (KLUN, '(A8," ",A8," ",A8," ",A8," ",A8," ",A8," ",A8)') "", "IRANK_G", &
     & "IRANK_L", "IVSET", "TYPE", "NAME"
DO J = 1, SIZE (YDGP)
  WRITE (KLUN, '(I8," ",I8," ",I8," ",I8," ",A8," ",A8)', ADVANCE='NO') &
 & J, YDGP (J)%IRANK_G, YDGP (J)%IRANK_L, YDGP (J)%IVSET, CFTYPE (YDGP (J)%ITYPE), YDGP (J)%CLNAME
  IF (ASSOCIATED (YDGP (J)%P)) THEN
!   WRITE (KLUN, '(" ",Z16.16)', ADVANCE='NO') LOC (YDGP (J)%P (1, 1))
  ENDIF
  WRITE (KLUN, *)
ENDDO

END SUBROUTINE

SUBROUTINE PRINTS (YDSP, KLUN)

TYPE (PTRS) :: YDSP (:)
INTEGER :: KLUN

INTEGER :: J

WRITE (KLUN, '(A8," ",A8," ",A8," ",A8," ",A8," ",A1)') &
     & "", "IPTR", "IPTR_NS", "TYPE", "NAME", "P"
DO J = 1, SIZE (YDSP)
  WRITE (KLUN, '(I8," ",I8," ",I8," ",A8," ",A8," ",L1)', ADVANCE='NO') &
       & J, YDSP (J)%IPTR, YDSP (J)%IPTR_NS, CFTYPE (YDSP (J)%ITYPE), YDSP (J)%CLNAME, ASSOCIATED (YDSP (J)%P)
  IF (ASSOCIATED (YDSP (J)%P)) THEN
!   WRITE (KLUN, '(" ",Z16.16)', ADVANCE='NO') LOC (YDSP (J)%P (1))
  ENDIF
  WRITE (KLUN, *)
ENDDO

END SUBROUTINE

CHARACTER*8 FUNCTION CFTYPE (KTYPE) 

INTEGER :: KTYPE

CFTYPE = ''

IF (IAND (KTYPE, NTYPE_VOR) /= 0) THEN
  CFTYPE = 'VOR'
ELSEIF (IAND (KTYPE, NTYPE_DIV) /= 0) THEN
  CFTYPE = 'DIV'
ELSEIF (IAND (KTYPE, NTYPE_U) /= 0) THEN
  CFTYPE = 'U'
ELSEIF (IAND (KTYPE, NTYPE_V) /= 0) THEN
  CFTYPE = 'V'
ELSEIF (IAND (KTYPE, NTYPE_S) /= 0) THEN
  CFTYPE = 'S'
ELSE
  STOP 1
ENDIF

IF (IAND (KTYPE, NTYPE_EW) /= 0) THEN
  CFTYPE = TRIM (CFTYPE)//'_EW'
ELSEIF (IAND (KTYPE, NTYPE_NS) /= 0) THEN
  CFTYPE = TRIM (CFTYPE)//'_NS'
ENDIF

END FUNCTION

SUBROUTINE RENUMG (YDGP)

USE TPM_DISTR, ONLY : MYSETV

TYPE (PTRG) :: YDGP (:)

INTEGER (KIND=JPIM) :: J, IRANK_L

IRANK_L = 0

DO J = 1, SIZE (YDGP)
  YDGP (J)%IRANK_G = J
  IF (YDGP (J)%IVSET == MYSETV) THEN
    IRANK_L = IRANK_L + 1
    YDGP (J)%IRANK_L = IRANK_L
  ENDIF
ENDDO

END SUBROUTINE

SUBROUTINE RENUMS (YDSP)

TYPE (PTRS) :: YDSP (:)

INTEGER (KIND=JPIM) :: J, I
INTEGER (KIND=JPIM) :: IPTR_NS (SIZE (YDSP))

IPTR_NS = 0
I = 0

DO J = 1, SIZE (YDSP)
  YDSP (J)%IPTR = J
  IF (IAND (YDSP (J)%ITYPE, NTYPE_NS) /= 0) THEN
    I = I + 1
    IPTR_NS (I) = J
  ENDIF
ENDDO

I = 0

DO J = 1, SIZE (YDSP)
  IF ((YDSP (J)%IPTR_NS > 0) .AND. IAND (YDSP (J)%ITYPE, NTYPE_NS) == 0) THEN
    I = I + 1
    YDSP (J)%IPTR_NS = IPTR_NS (I)
  ENDIF
ENDDO

END SUBROUTINE

END MODULE
